{
    "assets": {
        "script": [
            {
                "Game": {
                    "type": "game script",
                    "start": "set_room(\"Menu\")\r\n\r\n",
                    "loop": "self.mx = mouse_x()\r\nself.my = mouse_y()\r\n"
                }
            },
            {
                "Player": {
                    "type": "object script",
                    "start": "#Player start\nself.IDLE_SPRITE = sprite(\"player_idle.png\")\nself.MOVE_SPRITE = sprite(\"player_move.png\")\n\nself.sprite = self.IDLE_SPRITE\n\nself.obj_id = get_id()\n\nself.color = [random.randrange(0, 256) for i in range(3)]\nself.str_color = str(self.color)[1:-1].replace(\" \", \"\")\n\n#random colour\nfilterConfig = {\n    \"originalColor\":[i/255 for i in (0, 116, 33)],\n    \"newColor\": [i/255 for i in self.color],\n    \"epsilon\": 1\n}\n\n#add filter\nfilter = new_color_replace_filter(filterConfig)\nadd_filter(self, filter)\n\n\nself.vx = self.vy = 0\n\nself.standing = False\n\n\n# to check changes for multiplayer\nself.lastx = self.lasty = 0\nself.lastscalex = self.lastscaley = 0\nself.lastcolor = self.color\nself.lastsprite = self.sprite[\"spriteName\"]\n",
                    "loop": "#Movement code\n\nself.moved = False\n\n#Drag resistance - modifying these will change max velocity\nself.dragx = round(self.vx*0.182, 2)\nself.dragy = round(self.vy*0.082, 2)\n\nif key_is_pressed(\"arrowRight\"):\n    self.ax = 1\nelif key_is_pressed(\"arrowLeft\"):\n    self.ax = -1\nelse:\n    self.ax = 0\n\nif self.y - 32 <= -360:\n    self.y = -329\n    self.standing = True\n    self.vy = 0\n\n\nif self.standing:\n    if key_is_pressed(\"arrowUp\"):\n        self.ay = 25\n        self.standing = False\n    else:\n        self.ay = 0\nelse:\n    self.ay = -1.1\n\nif not get_collision(self, \"Block\"):\n    self.standing = False\n\nself.vx += self.ax - self.dragx\nself.vy += self.ay - self.dragy\n\n# otherwise you keep sliding veeeery slowly\nif abs(self.vx) < 0.1:\n    self.vx = 0\nif abs(self.vy) < 0.1:\n    self.vy = 0\n\n# apply velocities and do collision\nself.x += self.vx\nb = get_collision(self, \"Block\")\nif b:\n    if self.vx > 0:\n        self.x = b.x - (20 + 16)\n    else:\n        self.x = b.x + (20 + 16)\n        \nself.y += self.vy\nb = get_collision(self, \"Block\")\nif b:\n    if self.vy < 0:\n        self.y = b.y + (20 + 32)\n        self.standing = True\n\n    elif self.vy > 0:\n        self.y = b.y - (20 + 32)\n    self.vy = 0\n\n\nif abs(self.vx) > 0.2:\n    self.sprite = self.MOVE_SPRITE\n    self.scaleX = -1 if self.vx < 0 else 1\nelse:\n    self.sprite = self.IDLE_SPRITE\n\n# for multiplayer stuff\ncheck_player_change()\n\n"
                }
            },
            {
                "Block": {
                    "type": "object script",
                    "start": "\nself.temporary = False\nself.ctime = time_ms()\nself.life = 5000\nself.setup = False\n\n\nself.sprite = sprite(\"block.png\")",
                    "loop": "#Block loop\nif self.temporary:\n    if not self.setup:\n        self.obj_id = get_id()\n        self.setup = True\n    time_elapsed = (time_ms() - self.ctime)\n    \n    # fade out at end of life\n    if time_elapsed > self.life * 0.8:\n        self.alpha = (self.life - time_elapsed) / (self.life * 0.2)\n\n    if time_elapsed > self.life:\n        destroy(self)\n        return\n\n    game.tosend.append(self)\n"
                }
            },
            {
                "Button": {
                    "type": "object script",
                    "start": "# make_button(x, y, w, h, scaleX, scaleY, s_name, callback, animation=None z=2, inst=None):\n\n# non standard attributes, should be set by constructor\nself.animation = []\nself.callback = lambda: None\nself.w = 1\nself.h = 1\n\nself.anim_block = True\n\n# reference to original scale because it gets changed in animations\nself.scale_x = 1\nself.scale_y = 1\n\nself.down = False\nself.hover = False\nself.click = False\n\nself.exempt = 0",
                    "loop": "self.click = False\n\nif self.animation and not self.animation.finished:\n    self.animation.do_step()\n    if self.anim_block:\n        return\n\nw = (self.w * self.scaleX) / 2\nh = (self.h * self.scaleY) / 2\nx = self.x - camera_x()\ny = self.y - camera_y()\n\nxcol = x - w <= game.mx <= x + w\nycol = y-h <= game.my <= y + h\n\nif xcol and ycol:\n    self.hover = True\n    if mouse_was_pressed('left'):\n        self.down = True\n    if mouse_was_released('left') and self.down:\n        self.down = False\n        self.click = True\n        self.callback()\n\nelse:\n    self.hover = False\n\nif mouse_was_released('left'):\n    self.down = False\n\nif self.hover and not self.down:\n    self.alpha = 0.96\n    self.scaleX = self.scale_x + 0.06*self.scale_x\n    self.scaleY = self.scale_y + 0.06*self.scale_y\n\nelif self.down and not self.hover:\n    self.alpha = 0.96\n    self.scaleX = self.scale_x\n    self.scaleY = self.scale_y\n\nelif self.down and self.hover:\n    self.scaleX = self.scale_x - 0.06*self.scale_x\n    self.scaleY = self.scale_y - 0.06*self.scale_y\n    self.alpha = 0.96\n\nelse:\n    self.alpha = 1\n    self.scaleX = self.scale_x\n    self.scaleY = self.scale_y\n"
                }
            },
            {
                "Bullet": {
                    "type": "object script",
                    "start": "#Bullet start\nself.sprite = sprite(\"bullet.png\")",
                    "loop": "#Bullet loop\n\n"
                }
            },
            {
                "Object": {
                    "type": "object script",
                    "start": "#Object start\n\nself.obj_id = get_id()\nself.life = 5000",
                    "loop": "#Object loop\n\n"
                }
            }
        ],
        "room": [
            {
                "Menu": {
                    "type": "room script",
                    "start": "self.connecting = False\n\nright_anim = [\n    ['scaleX=,0 scaleY=,0', 1],\n    ['scaleX+,0.02 scaleY+,0.02 angle+,9 x+,7', 40],\n]\nleft_anim = [\n    ['scaleX=,0 scaleY=,0', 1],\n    ['scaleX+,0.02 scaleY+,0.02 angle-,9 x-,7', 40],\n]\n\ndef create_cb():\n    server_create_or_join(20, \"\")\n\ndef join_cb():\n    serverid = input()\n    if not serverid:\n        print(\"Server ID must be a valid id, not empty string\")\n        return\n    server_create_or_join(20, serverid)\n\ncreate_but = Button()\njoin_but = Button()\n\nmake_button(0, -50, 717, 195, 0.8, 0.8, 'create_button.png', create_cb, right_anim, inst=create_but)\nmake_button(0, -50, 717, 195, 0.8, 0.8, 'join_button.png', join_cb, left_anim, inst=join_but)\n",
                    "loop": "# while connecting to server\r\nif self.connecting:\r\n    connected = handle_server_events()\r\n    if connected:\r\n        self.connecting = False\r\n        \r\n        set_room(\"Game_Room\")"
                }
            },
            {
                "Game_Room": {
                    "type": "room script",
                    "start": "#Game_Room start\n\nself.c = 0\nself.ping_time = time_ms() + 1000\n\nself.grid = [\n    \"X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . X . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . X . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . X . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . X . X . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . . X X X . . . . . . . . . . . . . \",\n    \". . . . . . . . . . . . . . . X . . . . . . . . . . . . . . . . \",\n    \". . . X . . . . . . . . . . X . . . . . . . . . . . . . . . . X \"\n]\n\nself.tiles = []\n\nx0, y0 = -620, 340\nfor row in range(18):\n    for col in range(32):\n        if self.grid[row][col*2] == \"X\":\n\n            self.tiles.append(Block())\n            self.tiles[-1].x = x0 + col * 40\n            self.tiles[-1].y = y0 - row * 40\n\ngame.player = Player()\n\ngame.tosend = []\n\ngame.heartbeat_time = {}\ngame.remote_objs = {}\ngame.remote_obj_times = {}\n",
                    "loop": "#Game_Room loop\n\nself.c = (self.c+1)%60\nif not self.c:\n    print(get_fps())\n\nif self.ping_time > time_ms():\n    update_player()\n    self.ping_time += 1000\n\n\nsend_messages()\nhandle_inc_messages()"
                }
            }
        ],
        "texture": [
            {
                "player_idle.png": {
                    "type": "image",
                    "uri": "https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.332625.1637391011.player_idle.png"
                }
            },
            {
                "create_button.png": {
                    "type": "image",
                    "uri": "https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.332625.1637388707.create_button.png"
                }
            },
            {
                "join_button.png": {
                    "type": "image",
                    "uri": "https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.332625.1637388701.join_button.png"
                }
            },
            {
                "player_move.png": {
                    "type": "image",
                    "uri": "https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.332625.1637390926.player_move.png"
                }
            },
            {
                "block.png": {
                    "type": "image",
                    "uri": "https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.332629.1637432125.block.png"
                }
            },
            {
                "bullet.png": {
                    "type": "image",
                    "uri": "https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.332629.1637432267.bullet.png"
                }
            }
        ],
        "sound": [],
        "function": [
            {
                "Conventions.py": {
                    "type": "function script",
                    "head": "\"\"\"\n---CONVENTIONS---\n\n- 1 tile is 40x40\n- 1 player is 32x64\n- Game grid is 32 by 18 tiles\n\n\n\n\n\n\"\"\""
                }
            },
            {
                "imports_and_constants.py": {
                    "type": "function script",
                    "head": "from collections import deque\nimport random\nimport time\n\ndef time_ms(): return (time.time() * 1000)//1"
                }
            },
            {
                "misc_functions.py": {
                    "type": "function script",
                    "head": "def make_button(x, y, w, h, scaleX, scaleY, s_name, callback, animation=None, z=2, inst=None):\n    if inst is None:\n        inst = Button()\n    inst.x = x\n    inst.y = y\n    inst.w = w \n    inst.h = h\n    inst.scaleX = inst.scale_x = scaleX\n    inst.scaleY = inst.scale_y = scaleY\n    inst.sprite = sprite(s_name)\n    if animation is not None:\n        inst.animation = Animation(inst, animation)\n    inst.callback = callback\n    inst.z = z\n\ndef get_id():\n    new_id = \"\".join(chr(random.randrange(33, 127)) for i in range(11))\n    while \"|\" in new_id or \",\" in new_id:\n        new_id = \"\".join(chr(random.randrange(33, 127)) for i in range(11))\n    return new_id\n\nold_destroy = destroy\ndef destroy(obj):\n    # send destroy message here\n    old_destroy(obj)\n\ndef recolor(obj, old, new):\n    \"\"\"Change the color of an object.\n    \n    Arg \"obj\" is pixelpad object to change the color of, \"old\"\n    and \"new\" are tuples or lists of int rgb values.\n    \"\"\"\n\n    filterConfig = {\n        \"originalColor\": [c/255 for c in old],\n        \"newColor\": [c/255 for c in new],\n        \"epsilon\": 1 # adjust threshold as needed\n    }\n    replace = new_color_replace_filter(filterConfig)\n    add_filter(obj, replace)"
                }
            },
            {
                "Animation.py": {
                    "type": "function script",
                    "head": "class Animation:\n    def __init__(self, obj, steps):\n        self.commands = {\n            'scaleX+': self.scaleX_plus,\n            'scaleX-': self.scaleX_minus,\n            'scaleX=': self.scaleX_equals,\n            'scaleY+': self.scaleY_plus,\n            'scaleY-': self.scaleY_minus,\n            'scaleY=': self.scaleY_equals,\n            'angle+': self.angle_plus,\n            'angle-': self.angle_minus,\n            'angle=': self.angle_equals,\n            'x+': self.x_plus,\n            'x-': self.x_minus,\n            'x=': self.x_equals,\n            'y+': self.y_plus,\n            'y-': self.y_minus,\n            'y=': self.y_equals,\n            'wait': self.wait\n        }\n\n        self.obj = obj\n        self.finished = not bool(len(steps))\n\n        if not isinstance(steps, deque):\n            steps = deque(steps)\n        self.steps = steps\n\n        if not self.finished:\n            self.current = steps.popleft()\n            \n    def do_step(self):\n        if not self.finished:\n            # e.g. ['scaleX+,1 scaleY+,1', 5]\n            for c in self.current[0].split():\n                c = c.split(',')\n                self.commands[c[0]](float(c[1]))\n\n            self.current[1] -= 1\n\n            if self.current[1] <= 0:\n                try:\n                    self.current = self.steps.popleft()\n                except IndexError:\n                    self.finished = True\n\n    def scaleX_plus(self, n):\n        self.obj.scaleX += n\n    def scaleX_minus(self, n):\n        self.obj.scaleX -= n\n    def scaleX_equals(self, n):\n        self.obj.scaleX = n\n    def scaleY_plus(self, n):\n        self.obj.scaleY += n\n    def scaleY_minus(self, n):\n        self.obj.scaleY -= n\n    def scaleY_equals(self, n):\n        self.obj.scaleY = n\n    def angle_plus(self, n):\n        self.obj.angle += n\n    def angle_minus(self, n):\n        self.obj.angle -= n\n    def angle_equals(self, n):\n        self.obj.angle = n\n    def x_plus(self, n):\n        self.obj.x += n\n    def x_minus(self, n):\n        self.obj.x -= n\n    def x_equals(self, n):\n        self.obj.x = n\n    def y_plus(self, n):\n        self.obj.y += n\n    def y_minus(self, n):\n        self.obj.y -= n\n    def y_equals(self, n):\n        self.obj.y = n\n    def wait(self, n):\n        pass\n"
                }
            },
            {
                "multiplayer.py": {
                    "type": "function script",
                    "head": "def server_create_or_join(p_limit, serverid):\n    \"\"\"Attempt to create or join a server based on user input.\n    \n    If nothing is entered into the input popup, create a server.\n    Otherwise, attempt to join the server with entered ID.\n    \"\"\"\n\n    game.serverid = serverid\n    \n    if game.serverid:\n        join_server(game.serverid)\n    else:\n        create_server(p_limit)\n    get_room().connecting = True\n\n\ndef handle_server_events():\n    \"\"\"Handle confirmation of server creation and joining servers.\n    \n    Return True upon successful connection.\n    \"\"\"\n\n    event = get_server_event()\n\n    # handle create_server() response event\n    if event['type'] == 'server_created' and event['status']:\n        # join server with the server ID in event message\n        game.serverid = event['message']\n        join_server(game.serverid)\n        print(f'Created server with id: {game.serverid}')\n\n    # handle join_server() response event\n    elif event['type'] == 'self_joined' and event['status']:\n        print('Connected')\n        return True\n\n    # handle errors\n    elif event['type'] is not None and not event['status']:\n        print('ERROR CREATING/JOINING SERVER:')\n        print(event)\n\ndef add_obj(obj):\n    \"\"\"Add an object to the list that is sent to other players\"\"\"\n    obj_str = \",\".join([\n        obj.obj_id, obj.x, obj.y, obj.sprite[\"spriteName\"], obj.scaleX, obj.scaleY\n    ])\n    game.tosend.append(obj_str)\n\ndef send_messages():\n    while game.tosend:\n        msg = \"\"\n        nitems = len(game.tosend)\n        for i in range(nitems):\n            msg += \"|\" + game.tosend.pop(0)\n            if len(msg) > 256:\n                break\n        send_message(msg[1:])\n        \ndef handle_inc_messages():\n    for msg_group in get_messages():\n        msg_group = msg_group.split(\"|\")\n\n        for m in msg_group:\n            m = m.split(\",\")\n\n            # try to delete existing object\n            if m[0] == \"DEL\":\n                if m[1] in game.remote_objs:\n                    old_destroy(game.remote_objs[m[1]])\n                    del game.remote_objs[m[1]]\n                if m[1] in game.heartbeat_time:\n                    del game.heartbeat_time[m[1]]\n                if m[1] in game.remote_obj_times:\n                    del game.remote_obj_times[m[1]]\n                continue\n            \n            # create new object\n            if m[0] not in game.remote_objs:\n                o = Object()\n                game.remote_objs[m[0]] = o\n                if len(m) > 7:\n                    game.heartbeat_time[m[0]] = 4000\n                else:\n                    # default time to be destroyed\n                    game.remote_obj_times[m[0]] = 8000\n            \n            o = game.remote_objs[m[0]]\n\n            if len(m) > 7: # player\n                m, color = m[:-3], m[-3:]\n\n                color = [int(i) for i in color]\n                try:\n                    if o.color != color:\n                        o.color = color\n                        recolor(o, (0, 116, 33), color)\n                except AttributeError:\n                    o.color = color\n                    recolor(o, (0, 116, 33), color)\n            \n            o.obj_id = m[0]\n            o.x, o.y, o.scaleX, o.scaleY = [float(i) for i in (m[1], m[2], m[4], m[5])]\n            if o.sprite is None or m[3] != o.sprite[\"spriteName\"]:\n                o.sprite = sprite(m[3])\n\ndef check_player_change():\n    change = False\n    p = game.player\n    if p.lastx != p.x or p.lasty != p.y:\n        change = True\n        p.lastx = p.x\n        p.lasty = p.y\n    if p.lastscalex != p.scaleX or p.lastscaley != p.scaleY:\n        change = True\n        p.lastscalex = p.scaleX\n        p.lastscaley = p.scaleY\n    if p.lastcolor != p.color:\n        change = True\n        p.lastcolor = p.color\n    if p.lastsprite != p.sprite[\"spriteName\"]:\n        change = True\n        p.lastsprite = p.sprite[\"spriteName\"]\n    if change:\n        update_player()\n\n\ndef update_player():\n    p = game.player\n    pstring = \",\".join(map(str,\n        [p.obj_id, p.x, p.y, p.sprite[\"spriteName\"], p.scaleX, p.scaleY, p.str_color]\n    ))\n    game.tosend.append(pstring)\n\n\n\n"
                }
            }
        ]
    }
}